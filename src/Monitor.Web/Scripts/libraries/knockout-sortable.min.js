//knockout-sortable 0.7.0 | (c) 2012 Ryan Niemeyer | http://www.opensource.org/licenses/mit-license
(function (e) { typeof define == "function" && define.amd ? define(["knockout", "jquery", "jquery.ui.sortable"], e) : e(window.ko, jQuery) })(function (e, t, n) { var r = "ko_sortItem", i = "ko_sortList", s = "ko_parentList", o = "ko_dragItem", u = function (t, n) { e.utils.arrayForEach(t, function (t) { t.nodeType === 1 && (e.utils.domData.set(t, r, n), e.utils.domData.set(t, s, e.utils.domData.get(t.parentNode, i))) }) }, a = function (t, n) { var r = {}, i = e.utils.unwrapObservable(t()), s; return i.data ? (r[n] = i.data, r.name = i.template) : r[n] = t(), e.utils.arrayForEach(["afterAdd", "afterRender", "as", "beforeRemove", "includeDestroyed", "templateEngine", "templateOptions"], function (t) { r[t] = i[t] || e.bindingHandlers.sortable[t] }), n === "foreach" && (r.afterRender ? (s = r.afterRender, r.afterRender = function (e, t) { u.call(t, e, t), s.call(t, e, t) }) : r.afterRender = u), r }; e.bindingHandlers.sortable = { init: function (u, f, l, c, h) { var p = t(u), d = e.utils.unwrapObservable(f()) || {}, v = a(f, "foreach"), m = {}, g, y; e.utils.arrayForEach(u.childNodes, function (e) { e && e.nodeType === 3 && e.parentNode.removeChild(e) }), t.extend(!0, m, e.bindingHandlers.sortable), d.options && m.options && (e.utils.extend(m.options, d.options), delete d.options), e.utils.extend(m, d), m.connectClass && (e.isObservable(m.allowDrop) || typeof m.allowDrop == "function") ? e.computed({ read: function () { var t = e.utils.unwrapObservable(m.allowDrop), n = typeof t == "function" ? t.call(this, v.foreach) : t; e.utils.toggleDomNodeCssClass(u, m.connectClass, n) }, disposeWhenNodeIsRemoved: u }, this) : e.utils.toggleDomNodeCssClass(u, m.connectClass, m.allowDrop), e.bindingHandlers.template.init(u, function () { return v }, l, c, h), g = m.options.start, y = m.options.update; var b = setTimeout(function () { var a; p.sortable(e.utils.extend(m.options, { start: function (e, t) { t.item.find("input:focus").change(), g && g.apply(this, arguments) }, receive: function (t, n) { a = e.utils.domData.get(n.item[0], o), a && (a.clone && (a = a.clone()), m.dragged && (a = m.dragged.call(this, a, t, n) || a)) }, update: function (n, o) { var u, f, l, c, h, p, d = o.item[0], g = e.utils.domData.get(d, r) || a; a = null; if (this === o.item.parent()[0] && g) { u = e.utils.domData.get(d, s), f = e.utils.domData.get(d.parentNode, i), l = e.utils.arrayIndexOf(o.item.parent().children(), d); if (!v.includeDestroyed) { h = f(); for (c = 0; c < l; c++) h[c] && h[c]._destroy && l++ } if (m.beforeMove || m.afterMove) p = { item: g, sourceParent: u, sourceParentNode: u && d.parentNode, sourceIndex: u && u.indexOf(g), targetParent: f, targetIndex: l, cancelDrop: !1 }; if (m.beforeMove) { m.beforeMove.call(this, p, n, o); if (p.cancelDrop) { p.sourceParent ? t(p.sourceParent === p.targetParent ? this : o.sender).sortable("cancel") : t(d).remove(); return } } l >= 0 && (u && (u.remove(g), e.processAllDeferredBindingUpdates && e.processAllDeferredBindingUpdates()), f.splice(l, 0, g)), e.utils.domData.set(d, r, null), o.item.remove(), e.processAllDeferredBindingUpdates && e.processAllDeferredBindingUpdates(), m.afterMove && m.afterMove.call(this, p, n, o) } y && y.apply(this, arguments) }, connectWith: m.connectClass ? "." + m.connectClass : !1 })), m.isEnabled !== n && e.computed({ read: function () { p.sortable(e.utils.unwrapObservable(m.isEnabled) ? "enable" : "disable") }, disposeWhenNodeIsRemoved: u }) }, 0); return e.utils.domNodeDisposal.addDisposeCallback(u, function () { p.data("sortable") && p.sortable("destroy"), clearTimeout(b) }), { controlsDescendantBindings: !0 } }, update: function (t, n, r, s, o) { var u = a(n, "foreach"); e.utils.domData.set(t, i, u.foreach), e.bindingHandlers.template.update(t, function () { return u }, r, s, o) }, connectClass: "ko_container", allowDrop: !0, afterMove: null, beforeMove: null, options: {} }, e.bindingHandlers.draggable = { init: function (r, i, s, u, f) { var l = e.utils.unwrapObservable(i()) || {}, c = l.options || {}, h = e.utils.extend({}, e.bindingHandlers.draggable.options), p = a(i, "data"), d = l.connectClass || e.bindingHandlers.draggable.connectClass, v = l.isEnabled !== n ? l.isEnabled : e.bindingHandlers.draggable.isEnabled; return l = l.data || l, e.utils.domData.set(r, o, l), e.utils.extend(h, c), h.connectToSortable = d ? "." + d : !1, t(r).draggable(h), v !== n && e.computed({ read: function () { t(r).draggable(e.utils.unwrapObservable(v) ? "enable" : "disable") }, disposeWhenNodeIsRemoved: r }), e.bindingHandlers.template.init(r, function () { return p }, s, u, f) }, update: function (t, n, r, i, s) { var o = a(n, "data"); return e.bindingHandlers.template.update(t, function () { return o }, r, i, s) }, connectClass: e.bindingHandlers.sortable.connectClass, options: { helper: "clone" } } })